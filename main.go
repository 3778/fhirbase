package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/urfave/cli"
)

// AvailableSchemas contains all know FHIR versions
var AvailableSchemas = []string{
	"1.0.2", "1.1.0", "1.4.0",
	"1.6.0", "1.8.0", "3.0.1",
	"3.2.0", "3.3.0", "dev",
}

const logo = ` (        )  (    (                   (
 )\ )  ( /(  )\ ) )\ )   (     (      )\ )
(()/(  )\())(()/((()/( ( )\    )\    (()/( (
 /(_))((_)\  /(_))/(_)))((_)((((_)(   /(_)))\
(_))_| _((_)(_)) (_)) ((_)_  )\ _ )\ (_)) ((_)
| |_  | || ||_ _|| _ \ | _ ) (_)_\(_)/ __|| __|
| __| | __ | | | |   / | _ \  / _ \  \__ \| _|
|_|   |_||_||___||_|_\ |___/ /_/ \_\ |___/|___|        v1.0`

func main() {
	cli.AppHelpTemplate = fmt.Sprintf("%s\n\n%s", logo, cli.AppHelpTemplate)

	app := cli.NewApp()
	app.Name = "fhirbase"
	app.Usage = "command-line utility to operate on FHIR data with PostgreSQL database."

	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:        "host, n",
			Value:       "localhost",
			Usage:       "PostgreSQL host",
			EnvVar:      "PGHOST",
			Destination: &PgConfig.Host,
		},
		cli.UintFlag{
			Name:        "port, p",
			Value:       5432,
			Usage:       "PostgreSQL port",
			EnvVar:      "PGPORT",
			Destination: &PgConfig.Port,
		},
		cli.StringFlag{
			Name:        "username, U",
			Value:       "postgres",
			Usage:       "PostgreSQL username",
			EnvVar:      "PGUSER",
			Destination: &PgConfig.Username,
		},
		cli.StringFlag{
			Name:  "fhir, f",
			Value: "3.3.0",
			Usage: "FHIR version to use. Know FHIR versions are: " + strings.Join(AvailableSchemas, ", "),
		},
		cli.StringFlag{
			Name:        "db, d",
			Value:       "",
			Usage:       "Database to connect to",
			EnvVar:      "PGDATABASE",
			Destination: &PgConfig.Database,
		},
		cli.StringFlag{
			Name:        "password, W",
			Usage:       "PostgreSQL password",
			EnvVar:      "PGPASSWORD",
			Destination: &PgConfig.Password,
		},
	}

	app.Commands = []cli.Command{
		{
			Name:      "init",
			HelpName:  "init",
			Hidden:    false,
			Usage:     "Creates Fhirbase schema in specific database",
			UsageText: "fhirbase [--fhir=FHIR version] [postgres connection options] init",
			Description: `
Creates SQL schema (tables, types and stored procedures) for FHIR
resources from FHIR version specified with "--fhir" flag. Database
where schema will be created is specified with "--db" flag. Specified
database should be empty, otherwise command may fail with an SQL
error.`,
			Action: InitCommand,
		},
		{
			Name:      "transform",
			HelpName:  "transform",
			Hidden:    false,
			Usage:     "Performs Fhirbase transformation on a single FHIR resource loaded from a JSON file",
			UsageText: "fhirbase [--fhir=FHIR version] transform path/to/fhir-resource.json",
			Description: `
Transform command applies Fhirbase transformation algorithm to a
single FHIR resource loaded from provided JSON file and outputs result
to the STDOUT. This command exists mostly for demonstration and
debugging of Fhirbase transformation logic.

For detailed explanation of Fhirbase transformation algorithm please
proceed to the Fhirbase documentation. TODO: direct documentation
link.`,
			Action: TransformCommand,
		},
		{
			Name:      "bulkget",
			HelpName:  "bulkget",
			Hidden:    false,
			ArgsUsage: "[BULK DATA ENDPOINT] [TARGET DIR]",
			Usage:     "Downloads FHIR data from Bulk Data API endpoint and saves NDJSON files on local filesystem into specified directory",
			UsageText: "fhirbase bulkget [--numdl=10] http://some-fhir-server.com/fhir/Patient/$everything /output/dir/",
			Description: `
Downloads FHIR data from Bulk Data API endpoint and saves results into
specific directory on local filesystem.

NDJSON files generated by remote server will be downloaded in
parallel, and you can specify number of threads with "--numdl" flag.

To mitigate differences between Bulk Data API implementations, there
is an "--accept-header" option which sets the value for "Accept"
header. Must likely you won't neeed to set it, but if Bulk Data server
rejects queries because of "Accept" header value, consider explicitly
set it to something it expects.
`,
			Action: BulkGetCommand,
			Flags: []cli.Flag{
				cli.UintFlag{
					Name:  "numdl",
					Value: 5,
					Usage: "Number of parallel downloads for Bulk Data API client",
				},
				cli.StringFlag{
					Name:  "accept-header",
					Value: "application/fhir+json",
					Usage: "Value for Accept HTTP header (i.e. 'application/ndjson' for Cerner implementation)",
				},
			},
		},
		{
			Name:      "load",
			HelpName:  "load",
			Hidden:    false,
			Usage:     "Loads FHIR resources into database",
			ArgsUsage: "[BULK DATA URL or FILE PATH(s)]",
			Description: `
Load command loads FHIR resources from named source(s) into the
Fhirbase database.

You can provide either single Bulk Data URL or several file paths as a
load source.

Fhirbase can read from following files:

  * NDJSON files (one FHIR resource per line)
  * transaction or collection FHIR Bundles
  * regular JSON files containing single FHIR resource

Also Fhirbase can read gziped files, so all of the supported file
formats can be additionally gziped.

You are allowed to mix different file formats and gziped/non-gziped
files in a single command invocation, i.e.:

  fhirbase load *.ndjson.gzip patient-1.json transaction.json

Fhirbase automatically detects presence of gzip compression and format
of the input file, so you don't have to provide any additional
hints. Even file name extensions can be ommited, because Fhirbase
analyzes file content, not the file name.

If Bulk Data URL was provided, Fhirbase will download NDJSON files
first (see the help for "bulkget" command) and then load them as a
regular local files. Load command accepts all the command-line flags
accepted by bulkget command.

During load process Fhirbase sequentially reads one resource at a time
and puts it into the database until all of the provided files are
read. You can choose the method how resources are being loaded with
"--mode" flag. There are two modes: 'insert' and 'copy'.

With 'insert' mode Fhirbase uses INSERT statement to load resource
into the database. For the matter of speed Fhirbase buffers statements
and send them in batches of 2000.

Insert mode is intended for the cases when resources in your source
files are not sorted by resource type. In other words, if Fhirbase
always gets resources of a different types (different from previously
read resource), then you want to use insert mode.

Also insert mode is useful when you have duplicate IDs in your source
files (case is rare but happened several times). Insert mode can
ignore such duplicates.
`,
			Action: LoadCommand,
			Flags: []cli.Flag{
				cli.StringFlag{
					Name:  "mode, m",
					Value: "insert",
					Usage: "Load mode to use, possible values are 'copy' and 'insert'",
				},
				cli.UintFlag{
					Name:  "numdl",
					Value: 5,
					Usage: "Number of parallel downloads for Bulk Data API client",
				},
				cli.BoolFlag{
					Name:  "memusage",
					Usage: "Outputs memory usage during resources loading (for debug purposes)",
				},
				cli.StringFlag{
					Name:  "accept-header",
					Value: "application/fhir+json",
					Usage: "Value for Accept HTTP header (should be application/ndjson for Cerner, application/fhir+json for Smart)",
				},
			},
		},
		{
			Name:      "web",
			HelpName:  "web",
			Hidden:    false,
			Usage:     "Starts web server with primitive UI to perform SQL queries from the browser",
			ArgsUsage: "",
			Description: `
Starts a simple web server to invoke SQL queries from the browser UI.

You can specify web server's host and port with "--webhost" and
"--webport" flags. If "--webhost" flag is empty (set to blank string)
then web server will listen on all available network interfaces.`,
			Action: WebCommand,
			Flags: []cli.Flag{
				cli.UintFlag{
					Name:  "webport",
					Value: 3000,
					Usage: "Port to start webserver on",
				},
				cli.StringFlag{
					Name:  "webhost",
					Value: "",
					Usage: "Host to start webserver on",
				},
			},
		},
	}

	app.Action = func(c *cli.Context) error {
		cli.HelpPrinter(os.Stdout, cli.AppHelpTemplate, app)
		return nil
	}

	err := app.Run(os.Args)

	if err != nil {
		fmt.Printf("%+v\n", err)
		os.Exit(1)
	}

	os.Exit(0)
}
