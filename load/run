#!/usr/bin/env python3
import argparse
import json
import logging
import zipfile
from subprocess import Popen, PIPE
import io

import requests

logger = logging.getLogger()


# TODO: install requirements: requests
# TODO: install aidboxconv

parser = argparse.ArgumentParser(description='Load data into fhirbase')
parser.add_argument('-d', '--dbname', required=True,
                    help='destination DB')
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument(
    'files', metavar='file', nargs='*', default=[],
    help='load files in .json or .ndjson format (can be in archive)')
group.add_argument(
    '-b', '--bulk', metavar='url',
    dest='bulk', action='store',
    help='load files from external bulk API')
group.add_argument(
    '-s', '--synthea', metavar='directory',
    dest='synthea', action='store',
    help='load files from synthea output directory')
group.add_argument(
    '-e', '--external',
    metavar='url',
    dest='external', action='store',
    help='load files from external URL '
         '(in .json or .ndjson format, also can be in archive)')


args = parser.parse_args()


def isndjson(filename):
    return filename.endswith('.ndjson')


def isjson(filename):
    return filename.endswith('.json')


def iszip(filename):
    return filename.endswith('.zip')


def dumpjson(res):
    return json.dumps(res, separators=(',', ':'))


def loadjson(jsonstr):
    return json.loads(jsonstr)


def prepare_json(jsonstr):
    """
    Processes Bundle or another resource and
    returns its ndjson representation as list
    """
    res = loadjson(jsonstr)

    resource_type = res.get('resourceType', None)
    if not resource_type:
        return []

    if resource_type == 'Bundle' and 'entry' in res:
        return [dumpjson(item['resource'])
                for item in res['entry']
                if 'resource' in item]
    else:
        return [dumpjson(res)]


def iter_lines_from_files(files, openfn=open):
    """
    Generator which yield lines for each file from `files`.
    Input files can have format .ndjson, .json or .zip
    """
    for filename in files:
        try:
            mode = 'rb' if iszip(filename) else 'r'
            with openfn(filename, mode) as fd:
                if isndjson(filename):
                    for line in fd:
                        yield line.rstrip('\n')
                elif isjson(filename):
                    for line in prepare_json(fd.read()):
                        yield line
                elif iszip(filename):
                    with zipfile.ZipFile(fd) as zf:
                        for line in iter_lines_from_files(
                                zf.namelist(), zf.open):
                            yield line
                else:
                    logger.warn('Unknown file format for {0}'.format(filename))
        except FileNotFoundError:
            logger.warn('Cannot open file {0}'.format(filename))


def iter_lines_from_external(url):
    with requests.get(args.external, stream=True) as resp:
        if resp.status_code == 200:
            if isndjson(url):
                for line in resp.iter_lines():
                    yield line
            elif isjson(url):
                for line in prepare_json(resp.content):
                    yield line
            elif iszip(url):
                buf = io.BytesIO(resp.content)
                with zipfile.ZipFile(buf) as zf:
                    for line in iter_lines_from_files(zf.namelist(), zf.open):
                        yield line
            else:
                logger.warn('Unknown file format for {0}'.format(url))

        else:
            logger.warn('Cannot fetch url {0}'.format(args.external))


def import_lines(iterator):
    convcmd = ['java', '-jar', 'aidboxconv.jar', '1']
    copycmd = ['/usr/bin/env', 'psql', '-d', args.dbname,
               '-c', 'copy import (id, txid, resource_type, resource) '
                     'from stdin delimiter \',\'']

    total = 0
    with Popen(convcmd, stdin=PIPE, stdout=PIPE) as convproc, \
            Popen(copycmd, stdin=convproc.stdout, stdout=PIPE):
        for line in iterator:
            convproc.stdin.write(line.encode())
            convproc.stdin.write(b'\n')
            total += 1
        convproc.stdin.close()

    print('{0} entries imported'.format(total))


if args.files:
    import_lines(iter_lines_from_files(args.files))


if args.bulk:
    pass


if args.external:
    import_lines(iter_lines_from_external(args.external))


if args.synthea:
    pass
